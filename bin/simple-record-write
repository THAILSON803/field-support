#!/usr/bin/env node

const process = require('process')
const path = require('path')
const fs = require('fs')
const Web3 = require('web3')
const Accounts = require('web3-eth-accounts')
const util = require('util')

const thunderWsUrl = 'wss://mainnet-ws.thundercore.com'

const programName = () => {
    return path.basename(process.argv[1])
}

const signTx = async (fromAccount, chainId, gasLimit, gasPrice, nonce, toAddress, value, data) => {
    const fromAddress = fromAccount.address
    const nonceHex = Web3.utils.toHex(nonce)
    const rawTx = {
        'gasLimit': gasLimit,
        'chainId': chainId,
        'gasPrice': gasPrice,
        'nonce': nonceHex,
        'from': fromAddress,
        'to': toAddress,
        'value': value,
        'data': data,
    }
    // 'gasLimit': gasLimitHex,
    const signedTx = await fromAccount.signTransaction(rawTx)
    return signedTx.rawTransaction // hex string
}

const web3Url = () => {
    let u = process.env['WEB3_PROVIDER_URI']
    if (u === undefined) {
        u = thunderWsUrl
    }
    return u
}

const setup = async () => {
    const privateKeys = fs.readFileSync(path.join(__dirname, '..', '.private-keys'), {encoding: 'ascii'}).split('\n').filter(x => x.length > 0)
    const accounts = new Accounts()
    const account = accounts.privateKeyToAccount('0x' + privateKeys[0])
    const jsonBuf = fs.readFileSync(path.join(__dirname, '..', 'build', 'contracts', 'SimpleRecord.json'))
    const contractData = JSON.parse(jsonBuf)
    const contractAbi = contractData['abi']
    const web3ProviderUrl = web3Url()
    const web3 = new Web3(web3ProviderUrl)
    const networkId = await web3.eth.net.getId()

    let deployedNetwork, contractAddress
    try {
        deployedNetwork = contractData['networks'][networkId]
        contractAddress = deployedNetwork['address']
    } catch (err) {
        msg = `error getting deployedNetwork: ${err}`
        throw new Error(msg)
    }
    const contract = new web3.eth.Contract(contractAbi, contractAddress)
    return [ web3ProviderUrl, web3, networkId, contractAddress, contract, account ]
}

const recordWrite = async () => {
    const [web3ProviderUrl, web3, chainId, contractAddress, contract, account] = await setup()
    console.log('web3ProviderUrl:', web3ProviderUrl)
    const txnData = contract.methods.write().encodeABI()
    console.log('account.address:', account.address)
    const nonce = await web3.eth.getTransactionCount(account.address)
    const gasLimit = 100000
    const gasPrice = await web3.eth.getGasPrice()
    console.log('gasPrice:', gasPrice)
    const value = 0xbeef
    const rawTx = await signTx(account, chainId, gasLimit, gasPrice, nonce, contractAddress, value, txnData)
    const r = await web3.eth.sendSignedTransaction(rawTx)
    if (true) {
        console.log(util.inspect(r, {showHidden: false, depth: null, colors: true}))
    } else {
        console.log('SimpleRecord.write:', r)
        console.log('SimpleRecord.write: topics:', r['logs'][0]['topics'])
    }
    return 0
}

const eventSubscribe = () => {
    return new Promise((resolve, reject) => {
        setup().then(([web3ProviderUrl, web3, chainId, contractAddress, contract, account]) => {
            let eventCount = 0
            console.log('web3ProviderUrl:', web3ProviderUrl)
            console.log('contractAddress:', contractAddress)
            const subscription = web3.eth.subscribe('logs', { address: contractAddress }, (err, log) => {
                console.log('subscription callback')
                if (err) {
                    console.log('logs callback, err:', err)
                    reject(err)
                    return
                }
                //const e = web3.eth.abi.decodeLog(eventAbi.inputs, log.data, log.topics.slice(1))
                eventCount++
                console.log(`log[${eventCount}]:`, log)
                resolve(0)
            })
        })
    })
}

(async () => {
    if (programName().endsWith('-write')) {
        process.exit(await recordWrite())
    } else if (programName().endsWith('-event-subscribe')) {
        process.exit(await eventSubscribe())
    } else {
        console.error(`unsupported program name: "${programName()}"`)
        process.exit(2)
    }
})()
